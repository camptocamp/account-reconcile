# -*- coding: utf-8 -*-
##############################################################################
#
#    Author: Guewen Baconnier
#    Copyright 2013 Camptocamp SA
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

"""
Add an ``active`` field on the invoice so we can import historic
invoice as inactive.

The creation of the imported invoices is handled by
``sale/importer.py``.

Add a link between the refunds and the invoices that generated it.

"""

from openerp.osv import orm, fields
from openerp.tools.translate import _
from openerp.addons.connector.session import ConnectorSession
from .exporter import create_refund, cancel_refund
from ..unit.backend_adapter import api_handle_errors


class account_invoice(orm.Model):
    _inherit = 'account.invoice'

    _columns = {
        'active': fields.boolean('Active'),
        'refund_from_invoice_id': fields.many2one(
            'account.invoice',
            string='Refund generated from invoice',
            ondelete='restrict'),
        'refund_ids': fields.one2many(
            'account.invoice',
            'refund_from_invoice_id',
            string='Refund generated from invoice'),
    }

    _defaults = {
        'active': True,
    }

    def _prepare_refund(self, cr, uid, invoice, date=None, period_id=None,
                        description=None, journal_id=None, context=None):
        result = super(account_invoice, self)._prepare_refund(
            cr, uid, invoice, date=date, period_id=period_id,
            description=description, journal_id=journal_id, context=context)
        result['refund_from_invoice_id'] = invoice.id
        # Fix for case: OpenERP ID #32
        # In case of a refund of an invoice generated by Qoqa backend,
        # we need to set the account_id of the payment mode in order to
        # make the reconciliation with the refund done with the bank
        sales = invoice.sale_order_ids
        if sales:
            sale = sales[0]
            if sale.qoqa_bind_ids:
                # We will take payment method journal
                if sale.payment_method_id:
                    journal = sale.payment_method_id.journal_id
                    if journal:
                        account = journal.default_credit_account_id
                        result['account_id'] = account.id
        return result

    def refund_on_qoqa(self, cr, uid, ids, context=None):
        """ Create (synchronously) a refund in the qoqa backend.

        If the origin invoice/sales order does not comes from qoqa,
        just return.

        The call is synchronous, if it fails, the refund cannot be
        validated.  The qoqa backend will create a payment using a
        payment service (datatrans) and return a transaction ID.

        """
        for refund in self.browse(cr, uid, ids, context=context):
            invoice = refund.refund_from_invoice_id
            if not invoice:
                continue
            sales = invoice.sale_order_ids
            if not sales or not sales[0].qoqa_bind_ids:
                continue
            qsale = sales[0].qoqa_bind_ids[0]
            session = ConnectorSession(cr, uid, context=context)
            # with .delay() it would be created in a job,
            # here it is called synchronously
            message = _('Impossible to refund on the backend.')
            with api_handle_errors(message):
                create_refund(session,
                              'account.invoice',
                              qsale.backend_id.id,
                              refund.id)
        return True

    def invoice_validate(self, cr, uid, ids, context=None):
        result = super(account_invoice, self).invoice_validate(
            cr, uid, ids, context=context)
        self.refund_on_qoqa(cr, uid, ids, context=context)
        return result

    def cancel_refund_on_qoqa(self, cr, uid, ids, context=None):
        """ Cancel (synchronously) a refund in the qoqa backend.

        The call is synchronous, if it fails, the refund cannot be
        canceled.

        """
        for refund in self.browse(cr, uid, ids, context=context):
            invoice = refund.refund_from_invoice_id
            if not invoice:
                continue
            sales = invoice.sale_order_ids
            if not sales or not sales[0].qoqa_bind_ids:
                continue
            qsale = sales[0].qoqa_bind_ids[0]
            session = ConnectorSession(cr, uid, context=context)
            # with .delay() it would be created in a job,
            # here it is called synchronously
            message = _('Impossible to cancel a refund on the backend.')
            with api_handle_errors(message):
                cancel_refund(session,
                              'account.invoice',
                              qsale.backend_id.id,
                              refund.id)
        return True

    def action_cancel(self, cr, uid, ids, context=None):
        result = super(account_invoice, self).action_cancel(
            cr, uid, ids, context=context)
        self.cancel_refund_on_qoqa(cr, uid, ids, context=context)
        return result
